# 동기화 기법
## 공유 자원
- 여러 사용자나 프로세스가 동시에 접근하거나 사용하는 시스템 내 자원
- 파일 시스템, 네트워크 프린터, 메모리, DB 등
- 사용하는 이유
    - 리소스 낭비 방지: 자원을 특정 프로세스가 독점하면 리소스 낭비
    - 협업 효율성: 여러 사용자가 동시에 작업을 수행
- 은행 시스템에서 동일한 공유 자원이 아닌, 각각의 트랜잭션을 독립적으로 관리한다면, 여러 거래가 동시에 발생할 경우 잔액 오류가 발생 할 수 있음

## 임계 영역
- 공유 자원에 접근하는 프로그램 코드 중 충돌이 발생할 가능성이 있는 부분
- 공유 자원 전체를 보호하는게 아닌, 충돌이 발생할 가능성이 있는 부분만 보호하여 자원을 효율적으로 사용
- 데이터 무결성을 유지하고 경합 조건 방지

## 동기화
- 여러 스레드가 공유 자원에 접근할 때, 데이터의 일관성을 유지하고 예상치 못한 동작을 방지하기 위한 기법
- 동기화가 없다면 발생할 수 있는 문제
    - 데이터 경합: 여러 스레드가 동시에 공유 데이터를 수정할 때, 실행 순서에 따라 예기치 않은 결과가 발생하는 문제
    - 데드락: 여러 스레드가 서로 필요한 자원을 점유한 채 무한히 기다리는 상태
    - 기아 상태: 특정 스레드가 지속적으로 자원 할당에서 제외되어 실행되지 못하는 문제

## 임계 영역 문제 해결을 위한 3가지 조건

1. 상호 배제: 한 번에 하나의 프로세스만 임계 영역에 접근할 수 있도록 보장
2. 진행: 경쟁 프로세스가 없다면, 대기중인 프로세스가 반드시 임계 영역에 들어가 실행되어야 함
3. 유한한 대기: 특정 프로세스가 무한정 대기하지 않도록 보장

## 락
- 공유 자원에 대한 접근을 제어하기 위해 사용되는 동기화 기법
- 한 스레드가 락을 점유하면, 다른 스레드는 해당 락이 해제될 때까지 공유 자원에 접근 불가

## 락의 종류

### 스핀락
- 반복적으로 락이 해제됐는지 확인
실행 순서
1. T1이 락을 점유하고 작업을 수행함.
2. T2는 락이 해제될 때까지 지속적으로 확인함.
3. T1이 작업을 완료하고 락을 해제하면, T2가 락을 획득하여 실행됨.

장점
- 락을 기다리면서 대기 상태로 전환하지 않고, 반복적으로 확인하여 즉시 점유 가능
- 락 대기 중 컨텍스트 스위칭이 발생하지 않아 오버헤드가 적음
- 락을 짧은 시간만 유지할 경우 유용

단점
- Busy-waiting 방식(반복적 확인)으로 CPU 리소스 낭비
- 장시간 대기하는 경우거나 단일 CPU 환경에서 부적합

### 낙관적 락
- 충돌이 드물다는 가정하에 락 없이 작업을 수행하고, 충돌이 발생할 경우 롤백을 통해 해결
- 쓰기보다 읽기 작업이 많은 환경에서 사용

실행 순서
1. T1이 공유 자원의 일부를 점유하여 작업 시작
2. T2도 공유 자원의 일부에 접근하여 작업 시작(데이터 경합 없음)
3. T2가 T1이 사용중인 공유 자원을 요청 후 충돌 발생
4. 충돌 후 T1롤백(정책에 따라 T2롤백)

장점
- 락을 사용하지 않아, 충돌이 적은 환경에서 성능이 좋음
- 불필요한 락 점유를 줄여 병렬성이 좋음

단점
- 충돌이 많을 경우 반복적인 롤백으로 인해 성능이 저하될 수 있음

### Read-Write Lock
- 읽기와 쓰기를 구분하여 락을 관리
- 여러 Reader는 동시에 자원에 접근할 수 있고, Writer는 자원을 독점

실행 순서
1. Read Lock의 경우
    1. T의 읽기 요청. Read Lock 점유
    2. T2가 읽기 요청 시 T1과 Read Lock 공유
    3. T3가 쓰기 요청하지만, T1, T2의 Read Lock으로 인해 Writer 대기큐에 대기
    4. Read Lock이 해제되면 Writer큐에 notify 전달되고, T3이 Write Lock 점유
2. Write Lock의 경우
    1. T1이 쓰기 요청. Write Lock 점유
    2. T2가 읽기 요청하지만, T1의 Write Lock으로 인해 Reader 대기큐에 대기
    3. Write Lock이 해제되면 Reader 대기큐에 notify 전달되고, T2가 Read Lock 점유

장점
- 다수의 Reader가 동시에 자원에 접근할 수 있어, 읽기 중심의 작업에서 성능 유리

단점
- 많은 Reader가 연속적으로 자원을 점유할 경우, Writer가 락을 획득하지 못해 대기 시간이 길어질 수 있음(기아 상태)

## 뮤텍스
- 한 번에 하나의 스레드만 공유 자원에 접근할 수 있도록 보장하는 동기화 기법
- 특정 스레드가 자원 접근 권한을 획득할 때 다른 스레드는 대기

실행 순서
1. T1의 락 요청 및 점유, T2의 대기 큐 이동
    - T1은 락을 요청하고 성공적으로 점유하여 작업을 시작
    - T2가 접근을 시도했으나, 락이 이미 점유된 상태로 OS의 뮤텍스 대기 큐에 진입하여 대기 상태로 전환
2. T1의 작업 완료 및 락 해제
    - T1이 락을 해제하여 공유 자원이 비활성 상태로 전환
    - 뮤텍스 대기 큐의 첫번째 thread로 notify 신호가 전달되며, 락을 획득하기 위해 다시 접근

장점
- 한 번에 하나의 스레드만 자원을 사용하도록 제한해 데이터 무결성 보장

단점
- 락 대기 중 대기 상태로 전환되어 컨텍스트 스위칭으로 인한 오버헤드 발생
- 한 번에 하나의 스레드만 자원을 사용할 수 있으므로 병렬 처리가 제한

## 조건 변수
- 스레드가 특정 조건이 충족될 때까지 대기하거나, 다른 스레드가 신호를 보내 대기 중인 스레드를 깨워 실행을 재개하도록 하는 동기화 기법
- 일반적으로 뮤텍스 락과 함께 동작
- 뮤텍스 락이 해제되면 → 스레드를 깨움
- 하지만 특정 조건을 만족해야 스레드를 깨울 필요가 있는 경우 사용

실행 순서
1. T1의 락 요청 및 점유, T2는 조건이 충족되지 않아 대기
    - T1은 락 요청하고 성공적으로 점유하여 작업 시작
    - T2는 조건이 충족되지 않아 wait() 호출 후 조건 변수 대기 큐에 대기 상태로 들어감
2. T3의 락 요청 및 대기
    - T3은 락을 요청했지만, 점유 중이라 뮤텍스 대기큐로 이동
3. T1의 락 해제
    - T1이 락을 해제하여 공유 자원이 비활성 상태로 전환
    - 뮤텍스 대기 큐의 첫번째 thread로 notify 신호가 전달. T3이 락을 획득하기 위해 다시 접근
4. 조건 신호 충족
    - 조건 변수 큐에 대기중인 T2에게 조건 충족 신호 signal()를 보냄
    - T2는 깨어나 뮤텍스 락을 요청하지만, T3이 점유중이라 뮤텍스 대기 큐로 이동
5. T3의 락 해제 및 T2의 락 점유

## 세마포어
- 여러 개의 스레드가 공유 자원에 접근할 수 있도록 하되, 동시에 접근할 수 있는 스레드 수를 제한하는 동기화 기법
- 카운터 값을 통해 접근 가능 여부를 제어하며, 특정 스레드가 자원 접근 후 해제하면 대기 중인 스레드가 접근 가능

실행 순서
1. T1, T2, T3의 세마포어 접근 요청    
    - 초기 세마포어 값이 2라면, T1과 T2는 세마포어를 감소(`P() 연산`)시키고 자원에 접근 가능
    - T3는 접근을 시도했으나, 현재 사용 가능한 자원 수가 0이라 세마포어 대기 큐에 들어가 대기 상태로 전환
2. T1이 작업 완료 및 세마포어 해제
	- T1이 자원 사용을 끝내고 세마포어 값을 증가(`V() 연산`)
	- 대기 큐의 첫 번째 스레드(T3)에게 신호를 보내며, T3는 다시 접근을 시도
3. T3의 접근 허용 및 작업 수행
    - T3가 깨어나면서 세마포어 값을 감소시키고 자원을 사용
4. T2가 작업 완료 후 해제
    - T2도 작업을 완료하고 세마포어 값을 증가시키며, 대기 중인 스레드가 있으면 다시 접근 가능