# 이벤트 루프의 동작 원리
JS는 싱글 스레드 기반의 언어로, 하나의 실행 컨텍스트에서 코드가 실행된다.   
만약 싱글 스레드로 파일 다운로드와 같은 오래걸리는 작업을 수행한다면, 파일을 다 받을 때까지 다른 작업은 수행하지 못할 것이다.   
따라서 오래 걸리는 작업은 JS 엔진이 아닌, 브라우저(또는 NodeJS의 libuv 등)에서 멀티 스레드인 Web API에서 비동기로 처리한다.   

![[event-loop.png]]

## JS 엔진
- 우선 JS는 크게 콜 스택과 힙 영역으로 구성됨
- 콜 스택
	- 함수 호출이 발생할 때마다 쌓이는 스택(LIFO)
	- 실행이 끝난 함수는 스택에서 제거
- 힙
	- 동적으로 생성되는 객체가 저장되는 메모리 공간
	- 콜 스택에 쌓여 있는 실행 컨텍스트들은 힙에 저장된 객체를 참조
- JS 엔진은 항상 콜스택을 순차 실행함 -> 비동기를 위한 다른 장치 필요: 이벤트 루프와 태스크 큐

## 이벤트 루프와 태스크 큐
- 이벤트 루프
	- 현재 콜 스택에 비어 있는지를 확인하고, 비어 있다면 태스크 큐에 있는 작업을 실행 시킴(콜 스택으로 이동)
- 태스크 큐
	- 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 대기하는 큐
	- 이벤트 루프가 태스크 큐에 쌓인 콜백들을 순차적으로 콜 스택으로 전달

## 실행 흐름 
```javascript
console.log("1");

setTimeout(() => {
  console.log("4");
}, 1);

console.log("2");

let i = 0;
while (i < 1e9) i++;
console.log("3");
```
1. 전역 실행 컨텍스트가 생성되고 콜 스택에 push
2. `console.log("1");`이 콜 스택에 push되고 출력 후 pop됨
3. `setTimeout`이 콜스택에 push 되고, 타이머 호출을 스케쥴링하고 바로 pop
	- 타이머 만료 뒤 태스크 큐에 콜백함수` console.log("4");`를 넣어줌
4. `console.log("2");`이 콜 스택에 push 되고 출력 후 pop
5. `let i~ while~ console.log("3")`이 콜 스택에 push 후 실행 후 pop
	- 이 부분을 실행하면서 이벤트 루프는 계속 콜스택과 태스크 큐를 확인함
	- 그러나 콜스택에 전역 컨텍스트가 계속 남아있음
	- `console.log("3")`이 끝나야 전역 컨텍스트가 콜 스택에서 pop
6. 콜스택이 비어있고, 태스크 큐에 콜백이 존재
	- 이벤트 루프가 콜백을 콜 스택에 push후 실행 후 pop