## 날짜: 2025-02-04

### 스크럼
- 카테부 풀스택 1주차 과제 반려 내용 보충

### 새로 배운 내용
#### 프로세스와 스레드
- **프로세스와 스레드**
  - 프로세스: 연속적으로 실행되고 있는 컴퓨터 프로그램. 프로그램이 실제로 실행되면 프로세스라 불림
  - 스레드: 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위
  - 프로세스
    - 어떤 프로그램을 실행할 때 OS는 메모리 공간을 할당하고, 
    이 할당된 공간을 가지고 독립적으로 실행되는 것
    - 각자 독립된 메모리 영역을 가지며, 다른 프로세스와는 독립적으로 작동
  - 스레드
    - 한 프로세스 내에서 여러 스레드를 생성할 수 있으며, 이 스레드는 프로세스가 가진 자원을 공유
- **프로세스의 메모리 영역**
  - Code
    - 프로그램의 실행 코드나 명령어들이 기계어 형태로 저장되는 영역
    - CPU는 이 영역에 저장된 명령어들을 순차적으로 읽어서 처리함
  - Data
    - 코드에서 선언한 전역 변수와 정적 변수가 저장되는 영역
    - 프로그램이 실행되면서 할당되고 종료되면서 소멸
    - 전역 변수 : 프로그램 어디에서나 접근 가능한 변수
    - 정적 변수 (static variable) :  프로그램의 실행이 시작될 때 생성되고 종료될 때 소멸되는 변수로, 선언된 함수나 파일 내에서만 접근 가능
  - Stack
    - 함수의 호출과 관련된 지역 변수, 매개변수, 반환 값 등이 저장되는 영역
    - 함수가 호출되면 관련 정보가 스택에 쌓이고, 함수가 종료되면 해당 정보는 스택에서 제거
  - Heap
    - 동적으로 할당되는 데이터를 위한 자유 공간
    - 프로그래머는 실행 중인 프로그램의 요구에 따라 필요한 만큼의 메모리를 할당하고 해제할 수 있음
    - ex) 프로그램에서 사용자의 입력에 따라 변할 수 있는 데이터의 양을 관리할 때 주로 힙 영역을 사용

- **프로세스의 생명주기**
  1. 생성
      - 프로세스가 생성되는 단계
      - OS는 필요한 자원을 할당하고, 프로세스의 상태를 설정, 데이터 구조 초기화 등
  2. 준비
      - 프로세스가 CPU를 사용하여 실행될 준비가 된 상태
      - 이 상태의 프로세스들은 준비 큐에 있으며, 스케쥴러에 의해 선택되어 실행 상태로 전환될 수 있음
  3. 실행
      - 현재 CPU에서 실행되고 있는 상태
  4. 대기
      - 프로그램 실행 중에는 파일 입출력, 네트워크 통신과 같은 외부 이벤트가 발생할 수 있음
    이때 프로그램은 해당 이벤트가 완료될 때까지 대기 상태에 들어갈 수 있음
  5. 종료
      - 작업이 끝난 후 OS는 모든 자원을 회수하고, 해당 프로세서 관련 데이터 구조 제거
- **스레드의 생명주기**
  1. 생성
      - 프로세스 실행 중 추가적인 스레드를 생성
      - OS가 스레드를 동적으로 생성
      - 각 스레드는 고유의 실행 흐름을 가짐
      - ex) 메모장 저장 스레드가 생성되어 비동기로 파일 저장을 처리함
  2. 준비
     - 스레드가 스케쥴링 되는 것을 기다리는 상태
  3. 실행
      - 독립적인 실행 흐름으로 각 스레드가 작업을 처리
      - CPU 스케쥴링에 따라 병렬적으로 실행
      - ex) 메모장의 메인 스레드는 글 작성 작업 수행
  4. 대기
      - 스레드가 동기화나 외부 이벤트를 기다리는 상태
      - 스레드 간 동기화가 필요한 경우 대기
      - 파일 입출력, 네트워크 작업 등 외부 작업 완료까지 대기
      - ex) 저장 스레드가 디스크 쓰기 작업이 완료될 때까지 대기
  5. 종료
      - 스레드의 작업이 완료되어 자원을 반환
      - 스레드가 점유한 자원을 OS가 해제
      - 프로세스 내의 다른 스레드는 영향을 받지 않음
      - ex) 저장 작업이 완료되면 저장 스레드가 종료
- **멀티 프로세스/스레드**
  - 멀티프로세스
    - 2개 이상의 프로세스가 동시에 실행되는 것
    - 동시성과 병렬성
        - 동시성: CPU core가 1개일 때, 여러 프로세스를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템으로 실행되는 것
        - 병렬성: CPU core가 여러개일 때, 각각의 core가 각각의 프로세스를 연산함으로써 프로세스가 동시에 실행되는 것
    - Context Switch
        - 한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것
        - 이전의 프로세스 상태를 PCB(Process Control Block)에 저장하여 보관하고,
        새로운 프로세스의 PCB를 읽어 보관된 상태를 복구
    - Context: process가 현재 어떤 상태로 수행되고 있는지에 대한 정보로 PCB에 저장
    - PCB에 저장되는 정보
        - 프로세스 식별자(Process ID)
        - 프로세스 상태(Process State): 생성, 준비, 실행, 대기, 완료 상태
        - 프로그램 계수기(PC, Program Counter): 다음에 실행할 명령어의 주소
        - 레지스터
        - CPU 스케쥴링 정보: 우선순위, 실행시각, 점유시간 등
        - 메모리 관리 정보: 해당 프로세스의 주소 공간
        - 입출력 상태 정보: 프로세스에게 할당된 입출력장치 목록, 열린 파일 목록 등
        - 포인터: 부모 프로세스, 자식프로세스, 프로세스가 위치한 메모리 주소, 할당된 자원 등에 대한 포인터
  - 멀티스레드
    - 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것.
    - 멀티프로세스보다 적은 메모리 공간을 차지하고 컨텍스트 스위칭이 비교적 빠름
    - 하지만 동기화 문제가 발생할 수 있고, 하나의 스레드에서 문제가 발생했을때 전체 스레드에 영향을 미칠 수 있음

- **컨텍스트 스위칭**
  - 실행중인 스레드가 다른 스레드로 교체되는 현상
  - 이 때 두 스레드는 같은 프로세스에 속할수도, 다른 프로세스에 속할수도 있음
  - 여러 프로세스/스레드를 동시에 실행시키기 위해 필요함
  - 작동 과정
    - CPU의 레지스터 값 교체
        - PC(Program Counter), SP(Stack Pointer) 등 교체
    - 만약 다른 프로세스의 스레드로 컨텍스트 스위칭이 발생한다면 다른 공유 메모리를 사용하기 때문에
        - MMU(Memory Management Unit)이 실행될 작업의 메모리를 보도록 해야함
        - MMU내의 존재하는 TLB(가상주소→물리주소 변환 캐시 메모리)도 비워줌

#### 자바의 스레드와 동시성 제어
- Runnable Interface와 Thread Class
  - Runnable Interface
    - 함수형 인터페이스
    - 오직 run() 메소드만을 가지고 있음. 이 메소드 안에 스레드가 수행할 작업을 정의

  - Thread Class
    - 스레드와 직접적으로 연관된 start(), sleep(), join() 등의 메소드를 사용할 수 있음
    - class라 다중상속이 안돼서 유연하지 않다.
    - 실제 스레드를 생성하고 시작하는건 Thread 객체가 담당
  - 보통 Runnable에 스레드 실행 로직을 정의하고, 이를 Thread 객체에 넘겨주는 방식으로 사용 
- Java에서 지원하는 동시성 제어
  1. synchronized
    - synchronized가 선언된 블록에는 동시에 하나의 스레드만 접근할 수 있음(Lock 걸림)
    
    ```java
    public class Counter {
        int value;
    
        synchronized void increment() {
            value++;
        }
    }
    ```
    
  2. volatile
    - 항상 최신의 값을 메모리 영역에서 참조할 수 있게 함.
    - 동일 시점에 모든 스레드가 동일한 값을 가지도록 동기화
    - 하지만 set에서는 동시성 문제 발생. 단순히 캐시 없이 최신의 값을 참조 할 수 있게하는거기 때문
    
    ```java
    volatile int count = 0;
    ```
    
  3. Atomic 클래스
    - CAS 알고리즘 사용
        - 변수의 값을 변경하기 전에 기존 값이 예상했던 값과 일치하는 경우에만 새로운 값으로 갱신하는 방식으로, 락을 사용하지 않는다.
    
    ```java
    public class Counter {
        AtomicInteger value = new AtomicInteger(0);
    
        void increment() {
            while(true) {
                int oldValue = value.get();
                int newValue = oldValue + 1;
                if (value.compareAndSet(oldValue, newValue)) {
                    return;
                }
            }
        }
    }
    ```
#### RN Encrypted Storage
  - 데이터를 암호화하여 저장
  - 내부적으로 Keychain 등 사용
  - [React Native Encrypted Storage 함수들](https://boiling-pendulum-3bb.notion.site/React-Native-Encrypted-Storage-18fce97f383980a58cdfcb32dd199f8a?pvs=4)

### 오늘의 도전 과제와 해결 방법
- JAVA에서 synchronized와 Atomic 타입은 무슨 차이가 있을까? 성능 차이는 없을까?
  - 10만번의 연산을 하면서 공용 변수를 갱신시키는 2개의 스레드가 있다 하자.
  ``` java
  public class IncrementThread extends Thread {
      Counter counter;

      IncrementThread(Counter counter) {
          this.counter = counter;
      }

      @Override
      public void run() {
          for (int i=0; i<100000; i++) {
              counter.increment();
          }
      }
  }
  ```
1. synchronized를 사용했을 때
    ```java
    public class Counter {
        int value;

        synchronized void increment() {
            value++;
        }
    }
    ```
    5회 평균 18.2ms의 시간이 소요되었다.
2. AtomicInteger를 사용했을 때
    ```java
    public class Counter {
        AtomicInteger value = new AtomicInteger(0);

        void increment() {
            while(true) {
                int oldValue = value.get();
                int newValue = oldValue + 1;
                if (value.compareAndSet(oldValue, newValue)) {
                    return;
                }
            }
        }
    }
    ```
    5회 평균 9.6ms의 시간이 소요되었다.
3. 둘의 차이
    - Atomic 타입은 CAS(Compare And Swap) 방식으로 동기화 문제를 해결
    - CAS는 변수의 값을 변경하기 전에 기존 값이 예상했던 값과 일치하는 경우에만 새로운 값으로 갱신하는 방식으로, 락을 사용하지 않는다.
    - synchronized는 락을 사용하는데, 락을 획득하고 해제하는 과정에서 컨텍스트 스위칭 오버헤드가 발생
    - 결론: 단순한 연산과 레이스 경합이 잦을 경우는 AtomicInteger가 유리.
    하지만, 읽기/쓰기 모두 동기화가 필요하거나, 복잡한 연산의 경우는 synchronized가 유리할 수 있음.

### 오늘의 회고
- 반려당한 과제를 보며 자바에 대한 이해가 아직 부족함을 느꼈다. 
그 외에도 예외처리, 에러 메세지의 상수화 등 기본적인 부분을 놓친 점에 대해 피드백 받았다.   
간단한 과제여도 기본적인 부분을 잊지 말아야겠다.
- 프로세스와 스레드... 얕게 개념정리만 했는데도 양이 상당하다. 카테부 딥다이브 시간에 흥미로운 인사이트를 얻었으면 좋겠다.