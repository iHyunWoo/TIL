## 2025-03-05

## 새로 배운 내용
### INDEX
DB에서 검색 속도를 향상시키기 위해 사용되는 데이터 구조
- 클러스터형 인텍스
    - 테이블의 물리적 데이터 정렬 순서와 같은 순서로 저장되는 인덱스
    - PK에 대해 자동으로 생성되기도 함
- 비클러스터형 인덱스
    - 데이터가 물리적으로 정렬되지 않고 별도의 인덱스 테이블에 저장됨
    - 인덱스 테이블에는 원본 데이터 위치를 가리키는 포인터만 포함
- 인덱스는 검색 성능을 향상 시키지만,
    - DB의 용량이 증가하고, 데이터 변경 작업(CUD)이 발생하면 인덱스를 갱신해야 하므로 성능이 저하됨
    - 특히 인덱스를 갱신하는 작업은 테이블 단위로 Lock을 발생시키므로 실시간 서비스에서 치명적

### B-Tree / B+Tree
비클러스터형 인덱스는 B-Tree 또는 B+Tree와 같은 구조로 구현
B-Tree
- 균형 탐색 트리이며, 모든 노드에 데이터가 저장
- 루트부터 하향식 탐색하며 검색

B+Tree
- B-Tree를 개선한 구조로, 모든 데이터는 리프 노드에만 저장하고, 브랜치 노드는 인덱스만 저장
- 리프 노드들은 Linked List 형태로 연결되어 있어 범위 검색이 빠름

### 카디널리티
테이블의 컬럼에서 고유한 값의 개수
- 데이터의 중복 정도를 나타내는 개념으로, 인덱스 성능에 영향을 미침
- 카디널리티가 높다면 인덱스 검색 성능이 좋음
- 성별 컬럼의 값은 ‘남’, ‘여’로 카디널리티가 낮음
- 주민등록번호 컬럼의 카디널리티는 매우 높음

### 트랜잭션
DB에서 일련된 작업을 하나의 논리적 단위로 묶어 처리하는 개념
- 모든 작업이 성공해야 완료(Commit), 하나라도 실패하면 전체가 취소(Rollback)
- 트랜잭션의 특징(ACID)
    - Atomicity(원자성): 모든 작업이 전부 수행되거나 전혀 수행되지 않음
    - Consistency(일관성): 트랜잭션 수행 후 데이터의 무결성이 유지되어야 함
    - Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 주지 않아야 함
    - Durability(지속성): 트랜잭션이 성공적으로 완료되면, 데이터는 영구적으로 저장됨
- 트랜잭션의 격리 수준(Isolation level)
    - Read Uncommitted
        - 다른 트랜잭션의 커밋되지 않은 데이터도 모두 읽을 수 있음(Dirty Read 발생 가능)
    - Read Committed
        - 한 트랜잭션이 커밋된 후에만 다른 트랜잭션에서 그 결과를 볼 수 있음
        - 대부분의 RDBMS에서 기본적인 설정
        - 트랜잭션에서 반복적으로 조회 시 다른 트랜잭션의 커밋이 발생하면 최신의 값을 가져옴(Non-Repeatable Read)
    - Repeatable Read
        - 트랜잭션이 시작되기 전에 커밋된 데이터만 조회할 수 있음
        - 같은 트랜잭션 내에서 동일한 데이터를 여러 번 조회해도 항상 동일한 값을 반환
    - Serializable
        - 트랜잭션들을 순차적으로 실행하여 동시성 최소화

### NoSQL
RDBMS와 다르게 스키마가 없거나 유연한 DB. 대량의 데이터를 빠르게 처리
- 특징
    - 유연한 스키마
        - 변경 사항에 빠르게 적응 가능
        - 다양한 데이터를 유연하게 처리 가능
    - 수평 확장
        - RDBMS는 서버 성능을 높여 Scale up하지만, NoSQL은 여러 대의 서버를 추가하여 Scale Out
    - 대규모 데이터 처리
        - 분산 저장을 통해 병렬 데이터 처리 가능
        - 읽기/쓰기 속도가 빠름
- 종류
    - Key-Value Store
        - 키-값 형태로 데이터를 저장
        - Redis, DynamoDB
    - Document DB
        - JSON, XML과 같은 문서 형태로 저장
        - MongoDB, CouchDB 등
    - Column-based DB
        - 컬럼 단위로 데이터를 저장하고 관리하여, 빅데이터 분석에 유리
        - Cassandra, HBase 등
    - Graph DB
        - 데이터를 노드와 엣지로 표현
        - 객체 간의 관계를 중심으로 데이터를 처리
        - Neo4j 등
- CAP 이론
    - 분산 시스템이 세가지 속성(C, A, P)중 두 가지만 만족할 수 있다는 이론
    - Consistency(일관성): 모든 노드에서 같은 데이터를 반환
    - Availability(가용성): 일부 노드에 장애가 있어도 요청을 처리할 수 있어야 함
    - Partition Tolerance(파티션 허용 오차): 네트워크 장애가 발생해도 시스템이 동작해야 함
- Eventual Consistency(최종적 일관성)
    - NoSQL은 보통 일관성을 즉시 보장하는 것이 아닌, 시간이 지나면 결국 데이터가 일관성을 갖도록 설계하는 경우가 많은데, 이를 Eventual Consistency라 함
    - 분산 시스템에서 완벽한 실시간 일관성을 유지하는 것이 어렵고 성능 저하가 발생할 수 있기 때문

### 객체지향 4대요소에 대해 설명해주세요.
1. 캡슐화: 객체의 속성과 메서드를 접근제어자나 getter/setter를 사용하여 외부에서 직접 접근 못하도록 보호
2. 상속: 기존 클래스를 확장하여 새로운 클래스를 생성하여 재사용성과 유지보수성 향상
3. 다형성: 오버로딩, 오버라이딩과 같이 같은 인터페이스를 사용해 객체가 다양한 방식으로 동작
    - 오버로딩: 이름은 같지만 파라미터, 타입과 같은 시그니처가 다른 메서드를 선언
    - 오버라이딩: 부모 클래스의 메소드를 재정의하여 사용
4. 추상화: 불필요한 세부사항을 숨기고 핵심 기능만 노출

### B-Tree와 B+Tree의 차이점을 설명해주세요.
- B-Tree는 모든 노드들이 데이터를 가지지만, B+Tree는 리프노드만 데이터를 가지고 내부 노드는 인덱스만
- B-Tree는 리프노드간 연결이 없지만, B+Tree는 링크드 리스트로 연결되어있어 범위 검색에 효율적

### 카디널리티가 낮은 컬럼에 인덱스를 생성하는것이 왜 비효율적인지 설명해주세요.
- 카디널리티는 컬럼 내 고유한 값의 개수
- 낮은 카디널리티 컬럼의 인덱스는 동일한 값이 많아 인덱스를 거쳐도 필터링 효과가 낮음
- 결국 대량의 레코드를 다시 테이블에서 조회해야 함

### 커버링 인덱스가 성능 향상에 도움이 되는 이유를 설명해주세요.
- 커버링 인덱스는 쿼리가 조회하는 모든 컬럼을 포함하는 인덱스
- 인덱스에 필요한 모든 데이터가 들어 있어 테이블 조회가 불필요
- 디스크 I/O가 줄어들어 성능 향상
- 자주 조회하는 컬럼을 포함한 인덱스를 설계하면 성능 향상에 유리
- 하지만 너무 많은 인덱스는 저장 공간을 많이 차지하고 유지 비용이 들기 때문에 주의

### 트랜잭션 격리 수준별로 발생 가능한 문제를 설명해주세요.
- Read Uncommited
    - Dirty-Read: 커밋되지 않는 데이터가 다른 트랜잭션에서 읽히는 문제
    - Non-Repeatable Read, Phantom Read: 같은 데이터를 반복 조회했을 때, 다른 트랜잭션이 값을 변경 또는 추가/삭제하여 다른 결과가 반환
- Read Committed
    - 다른 크랜잭션이 커밋해야 값을 조회할 수 있으므로 Dirty-Read는 해결
    - 여전히 Non-Repeatable Read, Phantom Read는 발생
- Repeatable Read
    - 같은 조건을 조회하면 항상 같은 행을 반환하지만, 새로운 행이 추가되는 것은 막지 않아 Phantom Read 발생
- Serializable
    - 동시성을 최소화해 성능 저하

### 분산 시스템에서 ACID를 보장하기 어려운 이유를 설명해주세요.
- 네트워크 장애로 인해 일관성이 깨질 가능성
- 데이터 복제 등으로 인한 데이터 불일치 발생 가능

### CAP 이론에서 Consistency와 Availability의 트레이드오프를 예시와 함께 설명하라.
- Availability를 포기하여 일관성을 유지하면, 가용성이 떨어짐
    - 데이터 동기화가 완료될 때까지 읽기 불가
- Consistency를 포기하여 가용성을 유지하면, 일관성이 떨어짐
    - 한 노드에서 업데이트 후 다른 노드 반영 지연

### Eventual Consistency를 사용하는 시스템에서 데이터 충돌을 해결하는 방법을 설명해주세요.
- LWW(Last Write Wins)
    - 가장 최신 타임스탬프를 가진 데이터가 승리
    - Cassandra, DynamoDB에서 사용
- 버전 관리
    - 데이터에 버전을 부여하고, 충돌이 발생하면 애플리케이션 레벨에서 해결
    - Amazon S3의 버전관리, Git
- Quorum-based Approac(과반수 합의)
    - 다수의 노드에서 일관된 응답을 반환한 값을 정답으로 채택
    - Cassandra, DynamoDB의 `QUORUM` 옵션 사용

### MongoDB와 RDBMS의 스키마 설계 차이점을 설명해주세요.
RDBMS는 정해진 스키마가 필요하지만, MongoDB는 NoSQL로 유연한 스키마를 가짐
- RDBMS는 데이터 중복을 최소화하고 정합성을 보장함
    - 하지만 JOIN이 많아지면 성능 저하 가능
- MongoDB는 JSON을 저장하여 JOIN없이 빠른 조회 가능
    - 데이터 중복 발생 가능

## 오늘의 회고
- 기존 Community프로젝트를 바닐라JS를 유지할지, 아니면 리액트로 마이그레이션 할지 선택해야 했다.
- 앞으로 리액트 같은 라이브러리는 많이 사용할테니, 바닐라JS를 고도화 시키는 방안으로 결정했다.
- 기존 마구잡이 개발과 라우팅을 좀 정리했다.
- SPA기반으로 App과 Router를 만들고,
- 컴포넌트 기반으로 각 컴포넌트를 함수로 만들어 라우팅 했다.
- Fouc문제도 생겨 임시로 CSS 로딩되는 동안 body를 숨기게 해놨다. 이게 좋은 방법인지는 더 찾아봐야 함...
