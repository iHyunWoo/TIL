## 2025-03-04

## 새로 배운 내용
### Database
- 구조화된 정보 또는 데이터의 조직화된 모음
### 일관성과 무결성의 차이
- 일관성(Consistency)
    - 트랜잭션이 실행된 후에도 데이터가 유효한 상태를 유지해야 한다는 개념.
    - 데이터베이스에서 정의된 규칙(제약 조건, 외래 키 등)을 위반하지 않아야 함.
    - 예를 들어, 은행 계좌에서 10만 원을 송금하는 경우, A 계좌에서 -10만 원, B 계좌에서 +10만 원이 되어야 일관성이 유지됨.
- 무결성(Integrity)
    - 데이터가 정확하고 신뢰할 수 있도록 보장하는 개념.
    - 여러 종류가 있음:
        - 개체 무결성(Entity Integrity): 각 행이 고유해야 함 (PRIMARY KEY).
        - 참조 무결성(Referential Integrity): 외래 키가 항상 올바른 값을 가져야 함 (FOREIGN KEY).
        - 도메인 무결성(Domain Integrity): 특정 컬럼의 값이 허용된 범위를 벗어나면 안 됨 (CHECK).

### key의 종류
- 기본 키(Primary Key)
    - 테이블에서 각 행을 유일하게 식별하는 키
    - NULL 값을 가질 수 없음
- 외래 키(Foreign Key)
    - 한 테이블에서 다른 테이블의 PK를 참조하는 키
- 고유 키(Unique Key)
    - PK처럼 중복을 허용하지 않지만, NULL은 가질 수 있음
- 후보 키(Candidate Key)
    - PK가 될 수 있는 후보 중 하나
- 슈퍼 키(Super Key)
    - 테이블에서 유일성을 만족하는 모든 키의 조합
- 복합 키(Composite Key)
    - 두 개 이상의 컬럼을 조합하여 하나의 키로 사용하는 경우

### RDBMS

- 관계형 모델을 기반으로 데이터를 저장하고 관리하는 DBMS
- 특징
    - 데이터는 테이블 형태로 저장됨
    - SQL 사용
    - 정규화를 통해 데이터 중복 최소화
    - ACID 특성을 보장
        - 원자성(Atomicity)
            - 트랜잭션을 모두 실행(커밋)하거나, 모두 실행하지 않음(롤백) 두 가지 상태만 존재
            - 일부만 성공은 X
        - 일관성(Consistency)
            - 트랜잭션 이전과 이후에 DB는 항상 일관된 상태여야 함
            - ex)계좌의 잔액을 업데이트 하는데 트랜잭션의 결과로 잔액이 마이너스가 된다면 롤백해야함
        - 고립성(Isolation)
            - 여러 트랜잭션이 동시에 실행돼도 독립적으로 실행되는 것처럼 보여야 함(Concurrency control)
        - 지속성(Durability)
            - 커밋된 트랜잭션의 결과는 DB에 영구적으로 저장

### 정규화 / 역정규화
정규화
- 데이터 중복을 최소화하고, 무결성을 보장하는 과정
- 데이터 저장공간을 절약하고 변경 시 일관성을 유지할 수 있지만, JOIN이 많이지면서 조회 속도가 느려질 수 있음
- 1NF: 컬럼이 원자값으로만 구성
- 2NF: 부분적 함수 종속 제거(PK의 “일부에만” 종속된 컬럼이 없어야 함)
- 3NF: 이행적 함수 종속 제거
    - 컬럼이 PK가 아닌 다른 컬럼에 종속되면 안됨
    - ex) A→B, B→C일 때 A→C를 만족하면 이행적 함수 종속

역정규화
- 조회 성능 향상을 위해 일부 정규화 단계를 풀어 중복을 허용하는 것

### 함수 종속성
- 특정 값이 다른 값에 종속 되는 것
- X→Y: X가 Y를 결정함(Y가 X에 종속함)

### JOIN
- 두 개이상의 테이블을 연결하여 결과를 반환하는 연산
- Inner Join
    - 공통된 데이터만 가져옴
    - 두 테이블에서 매칭되는 행만 조회하는 경우 사용
- Left Join
    - 왼쪽 테이블의 모든 데이터 + 오른쪽 테이블의 매칭되는 데이터
    - 오른쪽 테이블에 매칭되는 값이 없으면 NULL
- Right Join
    - 오른쪽 테이블의 모든 데이터 + 왼족 테이블의 매칭되는 데이터
    - 왼쪽 테이블에 매칭되는 값이 없으면 NULL
- Full Outer Join
    - 두 테이블의 모든 데이터를 반환
    - 매칭되지 않는 부분은 NULL
- Join 사용시 주의해야할 점
    - 성능 저하
    - 불필요한 중복 데이터 발생 가능
    - N+1문제
    - 대량 데이터에서 조인 성능

### View
- 쿼리 결과를 가상 테이블처럼 사용
- 매번 실행될 때마다 원본 테이블에서 데이터를 가져옴
- Materialized View
    - 쿼리 결과를 물리적으로 저장하여 조회 성능을 높임
    - REFRESH로 최신 데이터를 갱신해야 함

### Union
- Union: 쿼리의 결과를 합침. 중복된 row는 제거
    - 중복 제거하는 과정으로 인해 성능 저하
- Union all: 중복 제거 안함

### ERD
- 데이터 모델을 시각적으료 표현하는 다이어그램
- 엔티티: 데이터의 주체(ex: 고객, 주문, 제품)
- 속성: 엔티티의 특징(ex: 고객의 이름, 주문 날짜)
- 관계: 엔티티 간의 연결(ex: 고객이 주문을 함)
- 관계 유형
    - 1:1 관계
        - 사용자는 한개의 프로필을 가짐
    - 1:N 관계
        - 한 과목에 여러 강의가 개설됨
    - M:N 관계
        - 학생은 여러 강의를 들을 수 있고, 하나의 강의는 여러 학생이 수강할 수 있음

### 복합키 사용하는 상황을 예시로 들어 설명해주세요
- 한 주문에서 여러 상품을 구매할 수 있어, 주문 상세 테이블에서 주문ID+상품ID를 복합키로 사용

### INNER JOIN과 LEFT JOIN의 차이를 예시로 설명해주세요
- Inner Join은 매칭되는 데이터만 반환, Left Join은 왼쪽 테이블에서 모든 데이터 반환, 오른쪽에 매칭되는 데이터가 없으면 null

### Materialized View와 일반 뷰의 차이점에 대해서 설명해주세요.
- View는 가상 테이블로, 실행할 때마다 원본 테이블에서 데이터를 조회
- Materialized View는 쿼리 결과를 저장하여 조회 성능을 높임. REFRESH를 통해 최신 데이터를 갱신해야 함

### VARCHAR와 CHAR 중 어떤것을 선택해야하나요?
- 사용자 이메일 처럼 다양한 길이를 받아야 할 때 VARCHAR사용.
- VARCHAR는 동적 크기를 가져 공간 절약 가능
- 해싱된 비밀번호 처럼 데이터 길이가 일정할 때 CHAR 사용
- CHAR는 데이터의 길이를 확인하는 연산이 없어 속도가 미세하게 빠름

### DATETIME과 TIMESTAMP의 차이점에 대해서 설명해주세요.

| 구분            | DATETIME                | TIMESTAMP               |
| ------------- | ----------------------- | ----------------------- |
| 저장 범위         | 1000-01-01 ~ 9999-12-31 | 1970-01-01 ~ 2038-01-19 |
| 크기            | 8바이트                    | 4바이트                    |
| 시간대(Timezone) | 영향 없음                   | 영향을 받음                  |

### GROUP BY와 HAVING의 차이점을 설명해주세요.
- group by는 데이터를 그룹화 할 때 사용하고 having은 grou by 결과를 필터링 할 때 사용

## 오늘의 회고
Keep
- 해커톤 이후 오랜만에 작성하는 TIL, 다시 페이스를 돌려보자

Problem
- 점점 이론보다 실제 개발을 하게 되는데 TIL에 작성할게 줄어들고 있다.

Try
- 여러 주제를 얕게 공부하지 말고, 한 주제라도 깊게 공부하는게 좋을 것 같다.
